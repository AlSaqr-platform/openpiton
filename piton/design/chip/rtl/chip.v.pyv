// Modified by Princeton University on June 9th, 2015
// ========== Copyright Header Begin ==========================================
//
// OpenSPARC T1 Processor File: iop.v
// Copyright (c) 2006 Sun Microsystems, Inc.  All Rights Reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES.
//
// The above named program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License version 2 as published by the Free Software Foundation.
//
// The above named program is distributed in the hope that it will be
// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this work; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
//
// ========== Copyright Header End ============================================

`ifndef USE_TEST_TOP // useless for older TOPs
`define PITON_NO_CHIP_BRIDGE
`include "define.tmp.h"
`include "piton_system.vh"
`include "jtag.vh"

module chip(
   // Input clocks
   input                                        core_ref_clk,
   // Resets
   // reset is assumed to be asynchronous
   input                                        rst_n,

   output                                       processor_offchip_noc1_valid,
   output [`NOC_DATA_WIDTH-1:0]                 processor_offchip_noc1_data,
   input                                        processor_offchip_noc1_yummy,
   output                                       processor_offchip_noc2_valid,
   output [`NOC_DATA_WIDTH-1:0]                 processor_offchip_noc2_data,
   input                                        processor_offchip_noc2_yummy,
   output                                       processor_offchip_noc3_valid,
   output [`NOC_DATA_WIDTH-1:0]                 processor_offchip_noc3_data,
   input                                        processor_offchip_noc3_yummy,

   input                                        offchip_processor_noc1_valid,
   input  [`NOC_DATA_WIDTH-1:0]                 offchip_processor_noc1_data,
   output                                       offchip_processor_noc1_yummy,
   input                                        offchip_processor_noc2_valid,
   input  [`NOC_DATA_WIDTH-1:0]                 offchip_processor_noc2_data,
   output                                       offchip_processor_noc2_yummy,
   input                                        offchip_processor_noc3_valid,
   input  [`NOC_DATA_WIDTH-1:0]                 offchip_processor_noc3_data,
   output                                       offchip_processor_noc3_yummy,
   // Debug                                    
    input                                       ndmreset_i,    // non-debug module reset
    input   [`NUM_TILES-1:0]                    debug_req_i,   // async debug request
    output  [`NUM_TILES-1:0]                    unavailable_o, // communicate whether the hart is unavailable (e.g.: power down)
    // CLINT
    input   [`NUM_TILES-1:0]                    timer_irq_i,   // Timer interrupts
    input   [`NUM_TILES-1:0]                    ipi_i,         // software interrupt (a.k.a inter-process-interrupt)
    // PLIC
    input   [`NUM_TILES*2-1:0]                  irq_i          // level sensitive IR lines, mip & sip (async) 
);

<%
    from pyhplib import *
%>

   ///////////////////////
   // Type Declarations
   ///////////////////////

   // ORAM muxed outputs (in our case is not muxed anymore)
   reg                                          proc_oram_yummy;
   reg                                          oram_proc_valid;
   reg  [`NOC_DATA_WIDTH-1:0]                   oram_proc_data;
   reg                                          offchip_oram_yummy;
   reg                                          oram_offchip_valid;
   reg  [`NOC_DATA_WIDTH-1:0]                   oram_offchip_data;

   // ORAM Signals
   wire                                         proc_oram_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   proc_oram_data;
   wire                                         proc_oram_yummy_oram;
   wire                                         oram_proc_valid_oram;
   wire [`NOC_DATA_WIDTH-1:0]                   oram_proc_data_oram;
   wire                                         oram_proc_yummy;

   wire                                         offchip_oram_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   offchip_oram_data;
   wire                                         offchip_oram_yummy_oram;
   wire                                         oram_offchip_valid_oram;
   wire [`NOC_DATA_WIDTH-1:0]                   oram_offchip_data_oram;
   wire                                         oram_offchip_yummy;


   // Chip bridge val/rdy interface
   wire                                         chip_intf_noc1_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   chip_intf_noc1_data;
   wire                                         chip_intf_noc1_rdy;
   wire                                         chip_intf_noc2_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   chip_intf_noc2_data;
   wire                                         chip_intf_noc2_rdy;
   wire                                         chip_intf_noc3_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   chip_intf_noc3_data;
   wire                                         chip_intf_noc3_rdy;

   wire                                         intf_chip_noc1_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   intf_chip_noc1_data;
   wire                                         intf_chip_noc1_rdy;
   wire                                         intf_chip_noc2_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   intf_chip_noc2_data;
   wire                                         intf_chip_noc2_rdy;
   wire                                         intf_chip_noc3_valid;
   wire [`NOC_DATA_WIDTH-1:0]                   intf_chip_noc3_data;
   wire                                         intf_chip_noc3_rdy;

   <%
       # generate wires
       for i in range(X_TILES):
           for j in range(Y_TILES):
               flatid = i + (j * X_TILES)
               print "wire tile%d_jtag_ucb_val;" % flatid
               print "wire [`UCB_BUS_WIDTH-1:0] tile%d_jtag_ucb_data;" % flatid
   %>

   // Generate tile wiring
<%
   if (NETWORK_CONFIG == "xbar_config"):
       for i in range(X_TILES + 1):
           for k in [1,2,3]:
               print "wire [`DATA_WIDTH-1:0] xbar_%d_out_noc%d_data;" % (i, k)
               print "wire xbar_%d_out_noc%d_valid;" % (i, k)
               print "wire xbar_%d_out_noc%d_yummy;" % (i, k)
       for i in range(X_TILES):
           for j in range(Y_TILES):
               for k in [1,2,3]:
                   print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_noc%d_data;" % (j,i,k)
                   print "wire tile_%d_%d_out_noc%d_valid;" % (j,i,k)
                   print "wire tile_%d_%d_out_noc%d_yummy;" % (j,i,k)
       # make offchip signals
       for k in [1,2,3]:
           print "wire [`DATA_WIDTH-1:0] offchip_out_noc%d_data;" % (k)
           print "wire offchip_out_noc%d_valid;" % (k)
           print "wire offchip_out_noc%d_yummy;" % (k)
   else:
       for i in range(X_TILES):
           for j in range(Y_TILES):
               currentid = (i, j);
               rightid = (i, j + 1);
               downid = (i + 1, j);
               flatid = i + (j * X_TILES);
               for k in [1,2,3]:
                   # print "`ifdef RTL_SPARC%d" % flatid
                   print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_N_noc%d_data;" % (j,i,k)
                   print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_S_noc%d_data;" % (j,i,k)
                   print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_E_noc%d_data;" % (j,i,k)
                   print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_W_noc%d_data;" % (j,i,k)
                   print "wire tile_%d_%d_out_N_noc%d_valid;" % (j,i,k)
                   print "wire tile_%d_%d_out_S_noc%d_valid;" % (j,i,k)
                   print "wire tile_%d_%d_out_E_noc%d_valid;" % (j,i,k)
                   print "wire tile_%d_%d_out_W_noc%d_valid;" % (j,i,k)
                   print "wire tile_%d_%d_out_N_noc%d_yummy;" % (j,i,k)
                   print "wire tile_%d_%d_out_S_noc%d_yummy;" % (j,i,k)
                   print "wire tile_%d_%d_out_E_noc%d_yummy;" % (j,i,k)
                   print "wire tile_%d_%d_out_W_noc%d_yummy;" % (j,i,k)
                   # print "`else"
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_N_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_S_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_E_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire [`DATA_WIDTH-1:0] tile_%d_%d_out_W_noc%d_data = `DATA_WIDTH'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_N_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_S_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_E_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_W_noc%d_valid = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_N_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_S_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_E_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "wire tile_%d_%d_out_W_noc%d_yummy = 1'b0;" % (j,i,k)
                   # print "`endif"
       # make some dummy signals
       for k in [1,2,3]:
           print "wire [`DATA_WIDTH-1:0] dummy_out_N_noc%d_data = `DATA_WIDTH'b0;" % (k)
           print "wire [`DATA_WIDTH-1:0] dummy_out_S_noc%d_data = `DATA_WIDTH'b0;" % (k)
           print "wire [`DATA_WIDTH-1:0] dummy_out_E_noc%d_data = `DATA_WIDTH'b0;" % (k)
           print "wire [`DATA_WIDTH-1:0] dummy_out_W_noc%d_data = `DATA_WIDTH'b0;" % (k)
           print "wire dummy_out_N_noc%d_valid = 1'b0;" % (k)
           print "wire dummy_out_S_noc%d_valid = 1'b0;" % (k)
           print "wire dummy_out_E_noc%d_valid = 1'b0;" % (k)
           print "wire dummy_out_W_noc%d_valid = 1'b0;" % (k)
           print "wire dummy_out_N_noc%d_yummy = 1'b0;" % (k)
           print "wire dummy_out_S_noc%d_yummy = 1'b0;" % (k)
           print "wire dummy_out_E_noc%d_yummy = 1'b0;" % (k)
           print "wire dummy_out_W_noc%d_yummy = 1'b0;" % (k)
       # make offchip signals
       for k in [1,2,3]:
           # print "wire [`DATA_WIDTH-1:0] offchip_out_S_noc%d_data;" % (k)
           print "wire [`DATA_WIDTH-1:0] offchip_out_E_noc%d_data;" % (k)
           # print "wire offchip_out_S_noc%d_valid;" % (k)
           print "wire offchip_out_E_noc%d_valid;" % (k)
           # print "wire offchip_out_S_noc%d_yummy;" % (k)
           print "wire offchip_out_E_noc%d_yummy;" % (k)
%>
   // Connecting chip_bridge data to tiles/ORAM
<%
   s = '''
   assign proc_oram_valid = tile_0_0_out_W_noc2_valid;
   assign proc_oram_data = tile_0_0_out_W_noc2_data;
   assign oram_proc_yummy = tile_0_0_out_W_noc3_yummy;'''
   if (NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign proc_oram_valid = xbar_X_TILES_out_noc2_valid;
   assign proc_oram_data = xbar_X_TILES_out_noc2_data;
   assign oram_proc_yummy = xbar_X_TILES_out_noc3_yummy;'''
   print s.replace("X_TILES", str(X_TILES))
%>
   assign offchip_oram_valid = offchip_processor_noc3_valid;
   assign offchip_oram_data = offchip_processor_noc3_data;
   assign oram_offchip_yummy = processor_offchip_noc2_yummy;
<%
   s = r'''
   assign processor_offchip_noc1_valid = tile_0_0_out_W_noc1_valid;
   assign processor_offchip_noc1_data = tile_0_0_out_W_noc1_data;
   assign offchip_processor_noc1_yummy = tile_0_0_out_W_noc1_yummy;'''
   if (NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign processor_offchip_noc1_valid = xbar_X_TILES_out_noc1_valid;
   assign processor_offchip_noc1_data = xbar_X_TILES_out_noc1_data;
   assign offchip_processor_noc1_yummy = xbar_X_TILES_out_noc1_yummy;'''
   print s.replace("X_TILES", str(X_TILES))
%>
   assign processor_offchip_noc2_valid = oram_offchip_valid;
   assign processor_offchip_noc2_data = oram_offchip_data;
<%
   s = r'''
   assign offchip_processor_noc2_yummy = tile_0_0_out_W_noc2_yummy;
   assign processor_offchip_noc3_valid = tile_0_0_out_W_noc3_valid;
   assign processor_offchip_noc3_data = tile_0_0_out_W_noc3_data;'''
   if (NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign offchip_processor_noc2_yummy = xbar_X_TILES_out_noc2_yummy;
   assign processor_offchip_noc3_valid = xbar_X_TILES_out_noc3_valid;
   assign processor_offchip_noc3_data = xbar_X_TILES_out_noc3_data;'''
   print s.replace("X_TILES", str(X_TILES))
%>
   assign offchip_processor_noc3_yummy = offchip_oram_yummy;
<%
   s = r'''
   assign offchip_out_E_noc1_data = offchip_processor_noc1_data;
   assign offchip_out_E_noc1_valid = offchip_processor_noc1_valid;
   assign offchip_out_E_noc1_yummy = processor_offchip_noc1_yummy;
   assign offchip_out_E_noc2_data = offchip_processor_noc2_data;
   assign offchip_out_E_noc2_valid = offchip_processor_noc2_valid;
   assign offchip_out_E_noc2_yummy = proc_oram_yummy; //going to processor
   assign offchip_out_E_noc3_data = oram_proc_data;
   assign offchip_out_E_noc3_valid = oram_proc_valid;
   assign offchip_out_E_noc3_yummy = processor_offchip_noc3_yummy;'''
   if (NETWORK_CONFIG == "xbar_config"):
       s = r'''
   assign offchip_out_noc1_data = offchip_processor_noc1_data;
   assign offchip_out_noc1_valid = offchip_processor_noc1_valid;
   assign offchip_out_noc1_yummy = processor_offchip_noc1_yummy;
   assign offchip_out_noc2_data = offchip_processor_noc2_data;
   assign offchip_out_noc2_valid = offchip_processor_noc2_valid;
   assign offchip_out_noc2_yummy = proc_oram_yummy; //going to processor
   assign offchip_out_noc3_data = oram_proc_data;
   assign offchip_out_noc3_valid = oram_proc_valid;
   assign offchip_out_noc3_yummy = processor_offchip_noc3_yummy;'''
   print s
%>
   always @ *
   begin
     // default is bypassing
     oram_offchip_valid = proc_oram_valid;
     oram_offchip_data = proc_oram_data;
     proc_oram_yummy = oram_offchip_yummy;
     oram_proc_valid = offchip_oram_valid;
     oram_proc_data = offchip_oram_data;
     offchip_oram_yummy = oram_proc_yummy;
  end
  
   // Merge all JTAG outputs from tiles together
<%
   t0 = 'assign tiles_jtag_ucb_val ='
   t1 = 'assign tiles_jtag_ucb_data ='
   for i in range(X_TILES):
       for j in range(Y_TILES):
           currentid = (i, j);
           flatid = i + (j * X_TILES);
           if flatid == 0:
               t0 = t0 + ' tile%d_jtag_ucb_val' % flatid
               t1 = t1 + ' tile%d_jtag_ucb_data' % flatid
           else:
               t0 = t0 + ' | tile%d_jtag_ucb_val' % flatid
               t1 = t1 + ' | tile%d_jtag_ucb_data' % flatid
   t0 = t0 + ';'
   t1 = t1 + ';'
   print t0
   print t1
%>

   /////////////////////////
   // Sub-module Instances
   /////////////////////////

  assign clk_muxed = core_ref_clk;

   // generate the cross bars
<%
   if (NETWORK_CONFIG == "xbar_config"):
       xbartemplate = r'''
       dynamic_node_top_wrap_para xbar_noc1(
           .clk                (clk_muxed),
           .reset_in           (~rst_n),

           .myChipID                   (14'b0),    // the first chip
           .myLocX                     (8'b0),  // not used
           .myLocY                     (8'b0),  // not used
       '''

       for i in range (X_TILES):
           for j in range (Y_TILES):
               xbartemplate += "    .dataIn_%d(tile_%d_%d_out_noc1_data),\n"  % (i, j,i)
               xbartemplate += "    .validIn_%d(tile_%d_%d_out_noc1_valid),\n"  % (i, j,i)
               xbartemplate += "    .yummyIn_%d(tile_%d_%d_out_noc1_yummy),\n"  % (i, j,i)
               xbartemplate += "    .dataOut_%d(xbar_%d_out_noc1_data),\n"  % (i, i)
               xbartemplate += "    .validOut_%d(xbar_%d_out_noc1_valid),\n"  % (i, i)
               xbartemplate += "    .yummyOut_%d(xbar_%d_out_noc1_yummy),\n\n"  % (i, i)

       xbartemplate += "    .dataIn_%d(offchip_out_noc1_data),\n"  % X_TILES
       xbartemplate += "    .validIn_%d(offchip_out_noc1_valid),\n"  % X_TILES
       xbartemplate += "    .yummyIn_%d(offchip_out_noc1_yummy),\n"  % X_TILES
       xbartemplate += "    .dataOut_%d(xbar_%d_out_noc1_data),\n"  % (X_TILES, X_TILES)
       xbartemplate += "    .validOut_%d(xbar_%d_out_noc1_valid),\n"  % (X_TILES, X_TILES)
       xbartemplate += "    .yummyOut_%d(xbar_%d_out_noc1_yummy),\n\n"  % (X_TILES, X_TILES)
       xbartemplate += "    .thanksIn_%d();\n" % (X_TILES)
       xbartemplate = xbartemplate[:-2] + r'''
       );'''

       print xbartemplate
       print xbartemplate.replace("noc1", "noc2")
       print xbartemplate.replace("noc1", "noc3")
%>

    // Generate tile instances
<%
    template = r'''
    tile #(.TILE_TYPE(TYPE_OF_TILE))
    tile0 (
        .clk                (clk_muxed),
        .rst_n              (rst_n),
        .clk_en             ( 1'b1 ),
        .default_chipid             (14'b0),    // the first chip
        .default_coreid_x           (COREIDX),
        .default_coreid_y           (COREIDY),
        .flat_tileid                (`JTAG_FLATID_WIDTH'd_FLAT_ID_),
    `ifdef PITON_ARIANE
        .debug_req_i         ( debug_req_i[_FLAT_ID_]   ),
        .unavailable_o       ( unavailable_o[_FLAT_ID_] ),
        .timer_irq_i         ( timer_irq_i[_FLAT_ID_]   ),
        .ipi_i               ( ipi_i[_FLAT_ID_]         ),
        .irq_i               ( irq_i[_FLAT_ID_*2 +: 2]  ),
    `endif
    '''

    subtemplate = r'''
        .dyn0_dataIn_N       ( in_N_noc1_data   ),
        .dyn0_dataIn_E       ( in_E_noc1_data   ),
        .dyn0_dataIn_W       ( in_W_noc1_data   ),
        .dyn0_dataIn_S       ( in_S_noc1_data   ),
        .dyn0_validIn_N      ( in_N_noc1_valid  ),
        .dyn0_validIn_E      ( in_E_noc1_valid  ),
        .dyn0_validIn_W      ( in_W_noc1_valid  ),
        .dyn0_validIn_S      ( in_S_noc1_valid  ),
        .dyn0_dNo_yummy      ( in_N_noc1_yummy  ),
        .dyn0_dEo_yummy      ( in_E_noc1_yummy  ),
        .dyn0_dWo_yummy      ( in_W_noc1_yummy  ),
        .dyn0_dSo_yummy      ( in_S_noc1_yummy  ),

        .dyn0_dNo            ( out_N_noc1_data  ),
        .dyn0_dEo            ( out_E_noc1_data  ),
        .dyn0_dWo            ( out_W_noc1_data  ),
        .dyn0_dSo            ( out_S_noc1_data  ),
        .dyn0_dNo_valid      ( out_N_noc1_valid ),
        .dyn0_dEo_valid      ( out_E_noc1_valid ),
        .dyn0_dWo_valid      ( out_W_noc1_valid ),
        .dyn0_dSo_valid      ( out_S_noc1_valid ),
        .dyn0_yummyOut_N     ( out_N_noc1_yummy ),
        .dyn0_yummyOut_E     ( out_E_noc1_yummy ),
        .dyn0_yummyOut_W     ( out_W_noc1_yummy ),
        .dyn0_yummyOut_S     ( out_S_noc1_yummy ),'''
        #.ec_dyn0            (                  ),'''
    if (NETWORK_CONFIG == "xbar_config"):
        subtemplate = r'''
        .dyn0_dataIn         ( in_noc1_data     ),
        .dyn0_validIn        ( in_noc1_valid    ),
        .dyn0_do_yummy       ( in_noc1_yummy    ),
        .dyn0_do             ( out_noc1_data    ),
        .dyn0_do_valid       ( out_noc1_valid   ),
        .dyn0_yummyOut       ( out_noc1_yummy   ),'''
    sub2 = subtemplate.replace('dyn0', 'dyn1');
    sub2 = sub2.replace("noc1", "noc2");
    sub3 = subtemplate.replace('dyn0', 'dyn2');
    sub3 = sub3.replace("noc1", "noc3");

    template += subtemplate + sub2 + sub3;
    template = template[:-1] + r'''
    );
    '''

    # generate the tiles
    for i in range(X_TILES):
        for j in range(Y_TILES):
            currentid = (i, j);
            flatid = i + (j * X_TILES);
            # print template
            currenttile = template.replace("tile0", "tile%d" % (flatid));
            currenttile = currenttile.replace("COREIDX", "8'd" + `i`);
            currenttile = currenttile.replace("COREIDY", "8'd" + `j`);
            currenttile = currenttile.replace("out_", "tile_%d_%d_out_" % (j,i));
            currenttile = currenttile.replace("_FLAT_ID_", `flatid`);

            if (PITON_PICO_HET):
                if (flatid % 2) == 0:
                    currenttile = currenttile.replace("TYPE_OF_TILE", "`SPARC_TILE")
                else:
                    currenttile = currenttile.replace("TYPE_OF_TILE", "`PICORV32_TILE")
            elif (PITON_PICO):
                currenttile = currenttile.replace("TYPE_OF_TILE", "`PICORV32_TILE")
            elif (PITON_ARIANE):
                currenttile = currenttile.replace("TYPE_OF_TILE", "`ARIANE_RV64_TILE")
            else:
                currenttile = currenttile.replace("TYPE_OF_TILE", "`SPARC_TILE")

            if (NETWORK_CONFIG == "xbar_config"):
                currenttile = currenttile.replace("in_", "xbar_%d_out_" % i);
            else:
                # now put in the data in direction
                if (j != 0):
                    idN = "tile_%d_%d" % (j-1, i)
                else:
                    idN = "dummy"

                if (j != Y_TILES - 1):
                    idS = "tile_%d_%d" % (j+1, i)
                else:
                    idS = "dummy"

                if (i != 0):
                    idW = "tile_%d_%d" % (j, i-1)
                else:
                    idW = "dummy"

                if (i != X_TILES - 1):
                    idE = "tile_%d_%d" % (j, i+1)
                else:
                    idE = "dummy"

                # special case for core 0
                if i == 0 and j == 0:
                    idW = "offchip"
                    idN = "dummy"

                currenttile = currenttile.replace("in_N", idN + "_out_S");
                currenttile = currenttile.replace("in_S", idS + "_out_N");
                currenttile = currenttile.replace("in_E", idE + "_out_W");
                currenttile = currenttile.replace("in_W", idW + "_out_E");

            # print "`ifdef RTL_SPARC%d" % flatid
            print currenttile;
            # print "`endif"
%>
endmodule

`endif
